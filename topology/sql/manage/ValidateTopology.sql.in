-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
--
--
-- PostGIS - Spatial Types for PostgreSQL
-- http://postgis.net
--
-- Copyright (C) 2010, 2021 Sandro Santilli <strk@kbt.io>
-- Copyright (C) 2005 Refractions Research Inc.
--
-- This is free software; you can redistribute and/or modify it under
-- the terms of the GNU General Public Licence. See the COPYING file.
--
-- Author: Sandro Santilli <strk@kbt.io>
--
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

--
-- Type returned by ValidateTopology
--
CREATE TYPE topology.ValidateTopology_ReturnType AS (
  error varchar,
  id1 integer,
  id2 integer
);

CREATE OR REPLACE FUNCTION topology._CheckEdgeLinking(curedge_edge_id INT, prevedge_edge_id INT, prevedge_next_left_edge INT, prevedge_next_right_edge INT)
RETURNS topology.ValidateTopology_ReturnType
AS
$BODY$
DECLARE
  retrec topology.ValidateTopology_ReturnType;
BEGIN
  IF prevedge_edge_id > 0
  THEN -- previous was outgoing, this one should be next-right
    IF prevedge_next_right_edge != curedge_edge_id THEN
#ifdef POSTGIS_TOPOLOGY_DEBUG
      RAISE DEBUG 'Edge % should be next-right of edge %, is % instead',
        curedge_edge_id,
        abs(prevedge_edge_id),
        prevedge_next_right_edge
      ;
#endif /* POSTGIS_TOPOLOGY_DEBUG */
      retrec.error = 'invalid next_right_edge';
      retrec.id1 = abs(prevedge_edge_id);
      retrec.id2 = curedge_edge_id; -- we put the expected one here, for convenience
      RETURN retrec;
    END IF;
  ELSE -- previous was incoming, this one should be next-left
    IF prevedge_next_left_edge != curedge_edge_id THEN
#ifdef POSTGIS_TOPOLOGY_DEBUG
      RAISE DEBUG 'Edge % should be next-left of edge %, is % instead',
        curedge_edge_id,
        abs(prevedge_edge_id),
        prevedge_next_left_edge
      ;
#endif /* POSTGIS_TOPOLOGY_DEBUG */
      retrec.error = 'invalid next_left_edge';
      retrec.id1 = abs(prevedge_edge_id);
      retrec.id2 = curedge_edge_id; -- we put the expected one here, for convenience
      RETURN retrec;
    END IF;
  END IF;

  RETURN retrec;
END;
$BODY$
LANGUAGE 'plpgsql' IMMUTABLE STRICT;

--
-- Check that the edges incident to topology nodes
-- (as advertised by their start_node/end_node)
-- correctly link to the next incident node on each
-- side (CW and CCW)
--
-- NOTE: if start_node/end_node values are incorrect the behavior
--       of this function is undefined
--
-- NOTE: assumes search_path was set before calling this function
--
CREATE OR REPLACE FUNCTION topology._ValidateTopologyEdgeLinking(bbox geometry DEFAULT NULL)
RETURNS SETOF topology.ValidateTopology_ReturnType
AS --{
$BODY$
DECLARE
  retrec topology.ValidateTopology_ReturnType;
  rec RECORD;
  last_node_id int;
  last_node_first_edge RECORD;
  last_node_prev_edge RECORD;
BEGIN
  RAISE NOTICE 'Checking edge linking';
  -- NOTE: this check relies on correct start_node and end_node
  --       for edges, if those are not correct the results
  --       of this check do not make much sense.
  FOR rec IN --{
      WITH
      nodes AS (
        SELECT node_id
        FROM node
        WHERE containing_face IS NULL
        AND (
          bbox IS NULL
          OR geom && bbox
        )
      ),
      incident_edges AS (
        SELECT
          n.node_id,
          e.edge_id,
          e.start_node,
          e.end_node,
          e.next_left_edge,
          e.next_right_edge,
          ST_RemoveRepeatedPoints(e.geom) as edge_geom
        FROM edge_data e, nodes n
        WHERE e.start_node = n.node_id
        or e.end_node = n.node_id
      ),
      edge_star AS (
        SELECT
          node_id,
          edge_id,
          next_left_edge,
          next_right_edge,
          ST_Azimuth(ST_StartPoint(edge_geom), ST_PointN(edge_geom, 2)) as az
        FROM incident_edges
        WHERE start_node = node_id
          UNION ALL
        SELECT
          node_id,
          -edge_id,
          next_left_edge,
          next_right_edge,
          ST_Azimuth(ST_EndPoint(edge_geom), ST_PointN(edge_geom, ST_NumPoints(edge_geom)-1))
        FROM incident_edges
        WHERE end_node = node_id
      ),
      sequenced_edge_star AS (
        SELECT
          row_number() over (partition by node_id order by az, edge_id) seq,
          *
        FROM edge_star
      )
      SELECT * FROM sequenced_edge_star
      ORDER BY node_id, seq
  LOOP --}{
    IF last_node_id IS NULL OR last_node_id != rec.node_id
    THEN --{
      IF last_node_id IS NOT NULL
      THEN
        -- Check that last edge (CW from prev one) is correctly linked
        retrec := topology._CheckEdgeLinking(
          last_node_first_edge.edge_id,
          last_node_prev_edge.edge_id,
          last_node_prev_edge.next_left_edge,
          last_node_prev_edge.next_right_edge
        );
        IF retrec IS NOT NULL
        THEN
          RETURN NEXT retrec;
        END IF;
#ifdef POSTGIS_TOPOLOGY_DEBUG
        RAISE DEBUG 'Finished analisys of edge star around node %', last_node_id;
#endif /* POSTGIS_TOPOLOGY_DEBUG */
      END IF;
#ifdef POSTGIS_TOPOLOGY_DEBUG
      RAISE DEBUG 'Analyzing edge star around node %', rec.node_id;
#endif /* POSTGIS_TOPOLOGY_DEBUG */
      last_node_id = rec.node_id;
      last_node_first_edge = rec;
    ELSE --}{
      -- Check that this edge (CW from last one) is correctly linked
      retrec := topology._CheckEdgeLinking(
        rec.edge_id,
        last_node_prev_edge.edge_id,
        last_node_prev_edge.next_left_edge,
        last_node_prev_edge.next_right_edge
      );
      IF retrec IS NOT NULL
      THEN
        RETURN NEXT retrec;
      END IF;
    END IF; --}
    last_node_prev_edge = rec;
  END LOOP; --}
  IF last_node_id IS NOT NULL THEN --{
#ifdef POSTGIS_TOPOLOGY_DEBUG
    RAISE DEBUG 'Out of loop: last_node_id: %', last_node_id;
    RAISE DEBUG 'Out of loop: last_node_first_edge edge_id:% next_left_edge:%', last_node_first_edge.edge_id, last_node_first_edge.next_left_edge;
    RAISE DEBUG 'Out of loop: last_node_prev_edge edge_id:% next_left_edge:%', last_node_prev_edge.edge_id, last_node_prev_edge.next_left_edge;
    RAISE DEBUG 'Out of loop: last_node_first_edge: %', last_node_first_edge;
#endif /* POSTGIS_TOPOLOGY_DEBUG */
    -- Check that last edge (CW from prev one) is correctly linked
    retrec := topology._CheckEdgeLinking(
      last_node_first_edge.edge_id,
      last_node_prev_edge.edge_id,
      last_node_prev_edge.next_left_edge,
      last_node_prev_edge.next_right_edge
      );
    IF retrec IS NOT NULL
    THEN
      RETURN NEXT retrec;
    END IF;
#ifdef POSTGIS_TOPOLOGY_DEBUG
    RAISE DEBUG 'Finished analisys of edge star around node % (out of loop)', last_node_id;
#endif /* POSTGIS_TOPOLOGY_DEBUG */
  END IF; --}


END;
$BODY$ --}
LANGUAGE 'plpgsql' VOLATILE;

--
-- Check that the edges forming all rings
-- (as advertised by their next_right_edge/next_left_edge)
-- consistently advertise the same face on the walking side
-- (CW or CCW)
--
-- NOTE: if next_right_edge/next_left_edge values are incorrect
--       the behavior of this function is undefined, use
--       _ValidateTopologyEdgeLinking to verify that
--
-- NOTE: assumes search_path was set before calling this function
--
CREATE OR REPLACE FUNCTION topology._ValidateTopologyRings(bbox geometry DEFAULT NULL)
RETURNS SETOF topology.ValidateTopology_ReturnType
AS --{
$BODY$
DECLARE
  retrec topology.ValidateTopology_ReturnType;
  nextEdge INT;
  rec RECORD;
  affected_rows integer;
  ring_poly GEOMETRY;
  is_shell BOOLEAN;
BEGIN
  RAISE NOTICE 'Gathering edges for side faces labeling';

  -- Pick all edges ending on any node in the bbox
  -- Those are the only edges we want to consider
  CREATE TEMP TABLE side_label_check_edge AS
  WITH edges_to_check AS (
    SELECT DISTINCT e.edge_id
    FROM edge_data e, node n
    WHERE (
      bbox IS NULL
      OR n.geom && bbox
    )
    AND (
      e.start_node = n.node_id
      OR e.end_node = n.node_id
    )
  )
  SELECT edge_id FROM edges_to_check
    UNION
  SELECT -edge_id FROM edges_to_check
  ;

  CREATE INDEX ON side_label_check_edge (edge_id);

  CREATE TEMP TABLE ring_check (
    ring_id int,
    ring_geom geometry, -- polygon for shell, line for hole
    is_shell boolean,
    bound_face int
  );

  RAISE NOTICE 'Checking edge rings';

  -- Find all rings that can be formed on both sides
  -- of selected edges
  affected_rows := 0;
  LOOP --{
    -- Fetch next unvisited edge
    SELECT edge_id
    FROM pg_temp.side_label_check_edge
    -- TODO: order by <-> from -inf/-inf to ensure catching
    --       shells before holes
    ORDER BY edge_id
    LIMIT 1
    INTO nextEdge;

    IF nextEdge IS NULL THEN
      EXIT; -- exit loop if no more unvisited edges found
    END IF;

    affected_rows := affected_rows + 1;

    -- Build ring formed on nextEdge
    -- Gather side faces for the ring formed on nextEdge
    WITH RECURSIVE
    edgering AS (
      SELECT
        nextEdge as signed_edge_id,
        edge_id,
        geom,
        next_left_edge,
        next_right_edge,
        CASE WHEN nextEdge > 0 THEN
          left_face
        ELSE
          right_face
        END as side_face
      FROM edge_data
      WHERE edge_id = abs(nextEdge)
        UNION
      SELECT
        CASE WHEN p.signed_edge_id < 0
        THEN
          p.next_right_edge
        ELSE
          p.next_left_edge
        END, -- signed_edge_id
        e.edge_id,
        e.geom,
        e.next_left_edge,
        e.next_right_edge,
        CASE WHEN p.signed_edge_id < 0
        THEN
          CASE WHEN p.next_right_edge > 0
          THEN
            e.left_face
          ELSE
            e.right_face
          END
        ELSE
          CASE WHEN p.next_left_edge > 0
          THEN
            e.left_face
          ELSE
            e.right_face
          END
        END -- side_face
      FROM edge_data e, edgering p
      WHERE
        e.edge_id = CASE
          WHEN p.signed_edge_id < 0 THEN
            abs(p.next_right_edge)
          ELSE
            abs(p.next_left_edge)
          END
    )
    SELECT
      ST_MakeLine(
        CASE WHEN signed_edge_id > 0 THEN
          geom
        ELSE
          ST_Reverse(geom)
        END
      ) ring_geom,
      array_agg(signed_edge_id) edges,
      array_agg(DISTINCT side_face) side_faces
    FROM edgering
    INTO rec;

#ifdef POSTGIS_TOPOLOGY_DEBUG
    RAISE DEBUG 'Ring % - edges:[%], faces:[%]',
      nextEdge,
      array_to_string(rec.edges, ','),
      array_to_string(rec.side_faces, ',')
    ;
#endif /* POSTGIS_TOPOLOGY_DEBUG */

    -- Check that there's a single face advertised
    IF array_upper(rec.side_faces,1) != 1
    THEN --{

#ifdef POSTGIS_TOPOLOGY_DEBUG
      RAISE DEBUG 'Side faces found on ring %: %', nextEdge, rec.side_faces;
#endif /* POSTGIS_TOPOLOGY_DEBUG */
      retrec.error = 'mixed face labeling in ring';
      retrec.id1 = nextEdge;
      retrec.id2 = NULL;
      RETURN NEXT retrec;

    ELSE --}{

      -- Save ring that a single face is ever used
      --       for each distinct CCW ring (shell)
      -- NOTE: multiple CW rings (holes) can exist for a given face
      --RAISE DEBUG 'Ring geom: %', ST_AsTexT(rec.ring_geom);
      IF NOT ST_Equals(
        ST_StartPoint(rec.ring_geom),
        ST_EndPoint(rec.ring_geom)
      )
      THEN --{
--        -- This should have been reported before,
--        -- on the edge linking check
--        retrec.error = 'non-closed ring';
--        retrec.id1 = nextEdge;
--        retrec.id2 = NULL;
--        RETURN NEXT retrec;
      ELSE --}{
        is_shell := false;
        IF ST_NPoints(rec.ring_geom) > 3 THEN
          ring_poly := ST_MakePolygon(rec.ring_geom);
          IF ST_IsPolygonCCW(ring_poly) THEN
            is_shell := true;
          END IF;
        END IF;
        INSERT INTO ring_check VALUES (
          nextEdge,
          CASE WHEN is_shell THEN
            ring_poly
          ELSE
            rec.ring_geom
          END,
          is_shell,
          rec.side_faces[1]
        );
      END IF; --}

    END IF; --}


    DELETE FROM pg_temp.side_label_check_edge
    WHERE edge_id = ANY (rec.edges);

  END LOOP; --}

  -- Check if any face has multiple shells
  RAISE NOTICE 'Checking multi-shell faces';
  FOR rec IN
    SELECT
      rc.bound_face,
      count(rc.ring_id)
    FROM ring_check rc
    WHERE rc.is_shell
    GROUP BY rc.bound_face
    HAVING count(rc.ring_id) > 1
  LOOP
    retrec.error = 'face has multiple shells';
    retrec.id1 = rec.bound_face;
    retrec.id2 = NULL;
    RETURN NEXT retrec;
  END LOOP;

  -- TODO: Check that holes really belong to the advertised shell
  -- NOTE: when limited by bounding box we might be missing the
  --       shell belonging to the most external holes, so for
  --       those we would need to

  RAISE NOTICE 'Completed checking % rings', affected_rows;

  DROP TABLE pg_temp.side_label_check_edge;
  DROP TABLE pg_temp.ring_check;


END;
$BODY$ --}
LANGUAGE 'plpgsql' VOLATILE;

--{
--  ValidateTopology(toponame, [bbox])
--
--  Return a Set of ValidateTopology_ReturnType containing
--  informations on all topology inconsistencies
--
-- Availability: 1.0.0
-- Changed: 3.2.0 - add bbox optional parameter
--
CREATE OR REPLACE FUNCTION topology.ValidateTopology(toponame varchar, bbox geometry DEFAULT NULL)
  RETURNS setof topology.ValidateTopology_ReturnType
AS
$$
DECLARE
  retrec topology.ValidateTopology_ReturnType;
  rec RECORD;
  rec2 RECORD;
  affected_rows integer;
  invalid_edges integer[];
  invalid_faces integer[];
  search_path_backup text;
BEGIN

  IF NOT EXISTS (
    SELECT oid
    FROM pg_catalog.pg_namespace
    WHERE nspname = toponame
  )
  THEN
    RAISE EXCEPTION 'Topology schema % does not exist', toponame;
  END IF;

  IF NOT EXISTS (
    SELECT id
    FROM topology.topology
    WHERE name = toponame
  )
  THEN
    RAISE WARNING 'Topology % is not registered in topology.topology', toponame;
  END IF;

  EXECUTE 'SHOW search_path' INTO search_path_backup;
  EXECUTE 'SET search_PATH TO ' || quote_ident(toponame) || ','
                                || search_path_backup;

  IF bbox IS NOT NULL THEN
    RAISE NOTICE 'Limiting topology checking to bbox %', ST_AsEWKT(ST_Envelope(bbox));
  END IF;


  -- Check for coincident nodes
  RAISE NOTICE 'Checking for coincident nodes';
  FOR rec IN
    SELECT a.node_id as id1, b.node_id as id2
    FROM
      node a,
      node b
    WHERE a.node_id < b.node_id
    AND ST_DWithin(a.geom, b.geom, 0) -- NOTE: see #1625 and #1789
    AND (
      bbox IS NULL
      OR (
        a.geom && bbox
        AND
        b.geom && bbox
      )
    )
  LOOP
    retrec.error = 'coincident nodes';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP;

  -- Check for edge crossed nodes
  -- TODO: do this in the single edge loop
  RAISE NOTICE 'Checking for edges crossing nodes';
  FOR rec IN
    SELECT n.node_id as nid, e.edge_id as eid
    FROM
      node n,
      edge e
    WHERE e.start_node != n.node_id
    AND e.end_node != n.node_id
    AND ST_Within(n.geom, e.geom)
    AND (
      bbox IS NULL
      OR (
        n.geom && bbox
        AND
        e.geom && bbox
      )
    )
  LOOP
    retrec.error = 'edge crosses node';
    retrec.id1 = rec.eid; -- edge_id
    retrec.id2 = rec.nid; -- node_id
    RETURN NEXT retrec;
  END LOOP;

  -- Scan all edges
  RAISE NOTICE 'Checking for invalid or not-simple edges';
  FOR rec IN
    SELECT e.geom, e.edge_id as id1, e.left_face, e.right_face
    FROM edge e
    WHERE (
      bbox IS NULL
      OR e.geom && bbox
    )
    ORDER BY edge_id
  LOOP --{

    -- Any invalid edge becomes a cancer for higher level complexes
    IF NOT ST_IsValid(rec.geom) THEN

      retrec.error = 'invalid edge';
      retrec.id1 = rec.id1;
      retrec.id2 = NULL;
      RETURN NEXT retrec;
      invalid_edges := array_append(invalid_edges, rec.id1);

      IF invalid_faces IS NULL OR NOT rec.left_face = ANY ( invalid_faces )
      THEN
        invalid_faces := array_append(invalid_faces, rec.left_face);
      END IF;

      IF rec.right_face != rec.left_face AND ( invalid_faces IS NULL OR
            NOT rec.right_face = ANY ( invalid_faces ) )
      THEN
        invalid_faces := array_append(invalid_faces, rec.right_face);
      END IF;

      CONTINUE;

    END IF;

    -- Check edge being simple (ie: not self-intersecting)
    IF NOT ST_IsSimple(rec.geom) THEN
      retrec.error = 'edge not simple';
      retrec.id1 = rec.id1;
      retrec.id2 = NULL;
      RETURN NEXT retrec;
    END IF;

  END LOOP; --}

  -- Check for edge crossing
  RAISE NOTICE 'Checking for crossing edges';
  FOR rec IN
    SELECT
      e1.edge_id as id1,
      e2.edge_id as id2,
      e1.geom as g1,
      e2.geom as g2,
      ST_Relate(e1.geom, e2.geom) as im
    FROM
      edge e1,
      edge e2
    WHERE
      e1.edge_id < e2.edge_id
      AND e1.geom && e2.geom
      AND (
        invalid_edges IS NULL OR (
          NOT e1.edge_id = ANY (invalid_edges)
          AND
          NOT e2.edge_id = ANY (invalid_edges)
        )
      )
      AND (
        bbox IS NULL
        OR (
          e1.geom && bbox
          AND
          e2.geom && bbox
        )
      )
  LOOP --{

    IF ST_RelateMatch(rec.im, 'FF1F**1*2') THEN
      CONTINUE; -- no interior intersection

    --
    -- Closed lines have no boundary, so endpoint
    -- intersection would be considered interior
    -- See http://trac.osgeo.org/postgis/ticket/770
    -- See also full explanation in topology.AddEdge
    --

    ELSIF ST_RelateMatch(rec.im, 'FF10F01F2') THEN
      -- first line (g1) is open, second (g2) is closed
      -- first boundary has puntual intersection with second interior
      --
      -- compute intersection, check it equals second endpoint
      IF ST_Equals(ST_Intersection(rec.g2, rec.g1),
                   ST_StartPoint(rec.g2))
      THEN
        CONTINUE;
      END IF;

    ELSIF ST_RelateMatch(rec.im, 'F01FFF102') THEN
      -- second line (g2) is open, first (g1) is closed
      -- second boundary has puntual intersection with first interior
      --
      -- compute intersection, check it equals first endpoint
      IF ST_Equals(ST_Intersection(rec.g2, rec.g1),
                   ST_StartPoint(rec.g1))
      THEN
        CONTINUE;
      END IF;

    ELSIF ST_RelateMatch(rec.im, '0F1FFF1F2') THEN
      -- both lines are closed (boundary intersects nothing)
      -- they have puntual intersection between interiors
      --
      -- compute intersection, check it's a single point
      -- and equals first StartPoint _and_ second StartPoint
      IF ST_Equals(ST_Intersection(rec.g1, rec.g2),
                   ST_StartPoint(rec.g1)) AND
         ST_Equals(ST_StartPoint(rec.g1), ST_StartPoint(rec.g2))
      THEN
        CONTINUE;
      END IF;

    END IF;

    retrec.error = 'edge crosses edge';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP; --}

  -- Check for edge start_node geometry mis-match
  -- TODO: move this in the first edge table scan
  RAISE NOTICE 'Checking for edges start_node mismatch';
  FOR rec IN
    SELECT e.edge_id as id1, n.node_id as id2
    FROM
      edge e,
      node n
    WHERE e.start_node = n.node_id
    AND NOT ST_Equals(ST_StartPoint(e.geom), n.geom)
    AND (
      bbox IS NULL
      OR e.geom && bbox
    )
  LOOP --{
    retrec.error = 'edge start node geometry mis-match';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP; --}

  -- Check for edge end_node geometry mis-match
  -- TODO: move this in the first edge table scan
  RAISE NOTICE 'Checking for edges end_node mismatch';
  FOR rec IN
    SELECT e.edge_id as id1, n.node_id as id2
    FROM
      edge e,
      node n
    WHERE e.end_node = n.node_id
    AND NOT ST_Equals(ST_EndPoint(e.geom), n.geom)
    AND (
      bbox IS NULL
      OR e.geom && bbox
    )
  LOOP --{
    retrec.error = 'edge end node geometry mis-match';
    retrec.id1 = rec.id1;
    retrec.id2 = rec.id2;
    RETURN NEXT retrec;
  END LOOP; --}

  -- Check for faces w/out edges
  RAISE NOTICE 'Checking for faces without edges';
  FOR rec IN
    SELECT face_id as id1
    FROM face
    WHERE face_id > 0
    AND (
      bbox IS NULL
      OR mbr && bbox
    )
    EXCEPT (
      SELECT left_face FROM edge
      UNION
      SELECT right_face FROM edge
    )
  LOOP --{
    retrec.error = 'face without edges';
    retrec.id1 = rec.id1;
    retrec.id2 = NULL;
    RETURN NEXT retrec;
  END LOOP; --}

  --- Validate edge linking
  RETURN QUERY SELECT * FROM topology._ValidateTopologyEdgeLinking(bbox);

  --- Validate edge rings
  RETURN QUERY SELECT * FROM topology._ValidateTopologyRings(bbox);


  -- Now create a temporary table to construct all face geometries
  -- for checking their consistency

  RAISE NOTICE 'Constructing geometry of all faces';

  CREATE TEMP TABLE face_check ON COMMIT DROP AS
  SELECT
    face_id,
    topology.ST_GetFaceGeometry(toponame, face_id) AS geom,
    mbr
  FROM
    face
  WHERE
    face_id > 0
    AND (
      CASE WHEN invalid_faces IS NOT NULL THEN
        NOT face_id = ANY(invalid_faces)
      ELSE
        TRUE
      END
    )
    AND (
      bbox IS NULL
      OR mbr && bbox
    )
  ;

  -- Build a gist index on geom
  CREATE INDEX "face_check_gist" ON face_check USING gist (geom);

  -- Build a btree index on id
  CREATE INDEX "face_check_bt" ON face_check (face_id);

  -- Scan the table looking for NULL geometries
  -- or geometries with wrong MBR consistency
  RAISE NOTICE 'Checking faces';
  affected_rows := 0;
  FOR rec IN
    SELECT * FROM face_check
  LOOP --{

    affected_rows := affected_rows + 1;

    IF rec.geom IS NULL OR ST_IsEmpty(rec.geom)
    THEN
      -- Face missing !
      retrec.error := 'face has no rings';
      retrec.id1 := rec.face_id;
      retrec.id2 := NULL;
      RETURN NEXT retrec;
    END IF;

    IF NOT ST_Equals(rec.mbr, ST_Envelope(rec.geom))
    THEN
#ifdef POSTGIS_TOPOLOGY_DEBUG
      RAISE DEBUG 'MBR expected:% obtained:%', ST_AsEWKT(ST_Envelope(rec.geom)), ST_AsEWKT(ST_Envelope(rec.mbr));
#endif /* POSTGIS_TOPOLOGY_DEBUG */
      -- Inconsistent MBR!
      retrec.error := 'face has wrong mbr';
      retrec.id1 := rec.face_id;
      retrec.id2 := NULL;
      RETURN NEXT retrec;
    END IF;

    FOR rec2 IN
      SELECT
        geom,
        face_id,
        ST_Relate(rec.geom, geom) as im
      FROM
        face_check
        WHERE face_id > rec.face_id
        AND geom && rec.geom
    LOOP --{

      -- Face overlap
      IF ST_RelateMatch(rec2.im, 'T*T***T**') THEN
        retrec.error = 'face overlaps face';
        retrec.id1 = rec.face_id;
        retrec.id2 = rec2.face_id;
        RETURN NEXT retrec;
      END IF;

      -- Face 1 is within face 2
      IF ST_RelateMatch(rec2.im, 'T*F**F***') THEN
        retrec.error = 'face within face';
        retrec.id1 = rec.face_id;
        retrec.id2 = rec2.face_id;
        RETURN NEXT retrec;
      END IF;

      -- Face 1 contains face 2
      IF ST_RelateMatch(rec2.im, 'T*****FF*') THEN
        retrec.error = 'face within face';
        retrec.id1 = rec.face_id;
        retrec.id2 = rec2.face_id;
        RETURN NEXT retrec;
      END IF;

    END LOOP; --}

  END LOOP; --}

  RAISE NOTICE 'Checked % faces', affected_rows;

  -- Check nodes have correct containing_face (#3233)
  RAISE NOTICE 'Checking for node containing_face correctness';
  FOR rec IN
    SELECT
      n.node_id,
      -- in a corrupted topology multiple faces may contain the node
      min(f.face_id) face_id,
      -- multiple edges may contain the node
      min(e.edge_id) edge_id
    FROM node n
    LEFT JOIN face_check f ON ( ST_Contains(f.geom, n.geom) )
    LEFT JOIN edge e ON (
      e.start_node = n.node_id OR
      e.end_node = n.node_id
    )
    WHERE
     ( bbox IS NULL OR n.geom && bbox )
     AND (
      (
        e.edge_id IS NULL AND (
          n.containing_face != f.face_id
          OR ( n.containing_face IS NULL AND f.face_id IS NOT NULL )
        )
      )
      OR ( n.containing_face IS NOT NULL AND e.edge_id IS NOT NULL)
    )
    GROUP BY n.node_id, n.containing_face
  LOOP --{
    IF rec.edge_id IS NOT NULL THEN
      -- node is not really isolated
      retrec.error := 'not-isolated node has not-null containing_face';
    ELSE
      retrec.error := 'isolated node has wrong containing_face';
    END IF;
    retrec.id1 := rec.node_id;
    retrec.id2 := NULL; -- TODO: write expected containing_face here ?
    RETURN NEXT retrec;
  END LOOP; --}

  -- Check edges are covered by their left-right faces (#4830)
  RAISE NOTICE 'Checking for edges coverage';
  FOR rec IN --{
    WITH
    face_coverage AS (
      SELECT f.face_id, array_agg(e.edge_id) covered_edges
      FROM face_check f, edge_data e
      WHERE ST_Covers(f.geom, e.geom)
      GROUP BY f.face_id
    ),
    edges_to_check AS (
      SELECT
        e.*
      FROM edge_data e
      WHERE ( bbox IS NULL OR e.geom && bbox )
      AND e.edge_id NOT IN (
        SELECT unnest(invalid_edges)
      )
    ),
    edge_coverage AS (
      SELECT
        e.edge_id,
        e.left_face,
        e.right_face,
        array_agg(DISTINCT fc.face_id)
          filter (WHERE fc.face_id IS NOT NULL) faces_covering
      FROM edges_to_check e
      LEFT JOIN face_coverage fc ON (
        e.edge_id = ANY(fc.covered_edges)
      )
      GROUP BY edge_id, left_face, right_face
    )
    SELECT *
    FROM edge_coverage
    WHERE
      -- Edges dangling in universal face needs be
      -- NOT covered by any face
      (
        left_face = 0 AND
        right_face = 0 AND
        faces_covering IS NOT NULL
      )
      OR
      (
        left_face != 0 AND
        (
          faces_covering IS NULL OR
          NOT left_face = ANY(faces_covering)
        )
      )
      OR
      (
        right_face != 0 AND
        (
          faces_covering IS NULL OR
          NOT right_face = ANY(faces_covering)
        )
      )
      OR
      (
        (
          ( right_face = 0 AND left_face != 0 )
          OR
          ( right_face != 0 AND left_face = 0 )
        )
        AND
        (
          faces_covering IS NULL OR
          array_upper(faces_covering, 1) != 1
        )
      )
    ORDER BY edge_id
  LOOP --}{
      retrec.id1 := rec.edge_id;
      retrec.id2 := NULL;
      IF rec.left_face = 0
         AND rec.right_face = 0
      THEN
        retrec.error := 'edge covered by some face has universal face on both sides';
        --retrec.error := format('edge covered by faces %s has universal face on both sides', rec.faces_covering);
        RETURN NEXT retrec;
      ELSE
        retrec.error := 'edge not covered by both its side faces';
        RETURN NEXT retrec;
--        IF rec.left_face != 0 AND NOT rec.left_face_covered THEN
--          retrec.error := 'edge not covered by its left face';
--          RETURN NEXT retrec;
--        END IF;
--        IF rec.right_face != 0 AND NOT rec.right_face_covered THEN
--          retrec.error := 'edge not covered by its right face';
--          RETURN NEXT retrec;
--        END IF;
      END IF;
  END LOOP; --}

  DROP TABLE face_check;

  EXECUTE 'SET search_PATH TO ' || search_path_backup;

  RETURN;
END
$$
LANGUAGE 'plpgsql' VOLATILE; -- NOTE: we need VOLATILE to use SHOW
--} ValidateTopology(toponame, bbox)

